
---
title: "Social and configural effects on the cognitive dynamics of perspective-taking"
authors: "Alexia Galati, Rick Dale, & Nick Duran"
date: "4/15/2017"
output:
  html_document: 
    keep_md: true  

  html_notebook: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list=ls())

library(pander)
library(lme4)
library(afex)
library(lmerTest)
library(MuMIn) 

source('xflip.R') # this also contains some functions we'll need (print_stats)

```

## Preliminaries for Exp 1A

Here we are loading in prior data analyzed using the scripts "GDD1_batchTrajectoryAnalysis.R". 
These include data from both the "error" (control) trials and the "ambiguous" (critical) trials of the experiment. 

We trim the data by removing trials that took more than 6000 ms from the initiation of the trial to selection of an initial folder or over 1000 pixels of total distance. These values reflect long tails of the distribution, well over 3 SD of their respective distributions. We chose to omit these trials because these radical divergences from their general distribution may reflect moments when the participant is not fully engaged in the task or understanding the trial. 

We then plot a histogram for the proportion of egocentric responses across participants.

Finally, we classify participants as egocentric, other-centric, and mixed responders based on their proportion of egocentric responses on ambiguous/critical trials. For classification, we computed the proportions of egocentric and other-centric responses of each listener on critical trials, and following Duran, Dale, and Kreuz (2011), if the proportion scores exceeded .70 for one of the two perspective categories, the listener was classified as member of that category; otherwise they were classified as a mixed responder.

In Exp 1A (GDD1A), the configural cue (i.e., the orientation of the folders appearing on the tabletop) is always aligned with the perspective of the participant/listener (ego-aligned configural cue).


```{r}

load('GDD1A_churnedRawTrajectoryData.Rd')

### Data cleaning and trimming ###

# Clean by approx. 3 SDs of M for control trials
resAllError1A = resAllError[resAllError$RTDV<6000&resAllError$totalDistanceDV<1000,]
resAll1A = resAll[resAll$RTDV<6000&resAll$totalDistanceDV<1000,]

# Create an aggregate variable to see distribution of egocentrism across subjects
egoChosen = 1*(resAll1A$chosen!=resAll1A$other)
perspectiveDistribution = aggregate(egoChosen~resAll1A$fl,FUN=mean)
hist(perspectiveDistribution$egoChosen,100, main = paste("Histogram of", "proportion of egocentrism in Exp 1A"), 
    xlab='Proportion of egocentrism',ylab='Number of subjects', ylim = range(0:20))

# Construct perspective preference variables
egoSubjects = perspectiveDistribution[perspectiveDistribution$egoChosen>.7,]$resAll1A
otherSubjects = perspectiveDistribution[perspectiveDistribution$egoChosen<.3,]$resAll1A
mixedSubjects = perspectiveDistribution[(perspectiveDistribution$egoChosen>=.3 & perspectiveDistribution$egoChosen<=.7) ,]$resAll1A

length(egoSubjects)
length(otherSubjects)
length(mixedSubjects)

length(unique(resAll1A$fl))

# Label perspectivePreference levels for Ambiguous/critical trials
resAll1A$perspectivePreference = 'mixed'
resAll1A$perspectivePreference[resAll1A$fl %in% egoSubjects]='ego'
resAll1A$perspectivePreference[resAll1A$fl %in% otherSubjects]='other'

# For Control trials let's trasfer the perspectivePreference variable over 
resAllError1A$perspectivePreference = 'mixed'
resAllError1A$perspectivePreference[resAllError1A$fl %in% egoSubjects]='ego'
resAllError1A$perspectivePreference[resAllError1A$fl %in% otherSubjects]='other'

# Add label for new Experiment (Exp) variable in the dataframes for Ambiguous/critical and Control trials
resAll1A$Exp = "1A" #Experiment 1A: folder orientation is constant = always aligned with ego
resAllError1A$Exp = "1A" #Experiment 1A: folder orientation is constant = always aligned with ego

```

## Preliminaries for Exp 1B

We repeat the same process for Exp 1B.

In Exp 1B (GDD1B), the configural cue (i.e., the orientation of the folders appearing on the tabletop) is always aligned with the perspective of the task partner/speaker (other-aligned configural cue).

The two experiments are otherwise identical.

```{r}

# Same procedure for Exp 1B 
load('GDD1B_churnedRawTrajectoryData.Rd') 

### Data cleaning and trimming ###

# Clean by approx. 3 SDs of M for control trials
resAllError1B = resAllError[resAllError$RTDV<6000&resAllError$totalDistanceDV<1000,]
resAll1B = resAll[resAll$RTDV<6000&resAll$totalDistanceDV<1000,]

# Create an aggregate variable to see distribution of egocentrism across subjects
egoChosen = 1*(resAll1B$chosen!=resAll1B$other)
perspectiveDistribution = aggregate(egoChosen~resAll1B$fl,FUN=mean)

hist(perspectiveDistribution$egoChosen,100, main = paste("Histogram of", "proportion of egocentrism in Exp 1B"), 
     xlab='Proportion of egocentrism',ylab='Number of subjects', ylim = range(0:30))

# Construct perspective preference variables
egoSubjects = perspectiveDistribution[perspectiveDistribution$egoChosen>.7,]$resAll1B
otherSubjects = perspectiveDistribution[perspectiveDistribution$egoChosen<.3,]$resAll1B
mixedSubjects = perspectiveDistribution[(perspectiveDistribution$egoChosen>=.3 & perspectiveDistribution$egoChosen<=.7) ,]$resAll1B

length(egoSubjects)
length(otherSubjects)
length(mixedSubjects)

length(unique(resAll1B$fl))

# Label perspectivePreference levels for Ambiguous/critical trials
resAll1B$perspectivePreference = 'mixed'
resAll1B$perspectivePreference[resAll1B$fl %in% egoSubjects]='ego'
resAll1B$perspectivePreference[resAll1B$fl %in% otherSubjects]='other'

# For Control trials let's trasfer the perspectivePreference variable over 
resAllError1B$perspectivePreference = 'mixed'
resAllError1B$perspectivePreference[resAllError1B$fl %in% egoSubjects]='ego'
resAllError1B$perspectivePreference[resAllError1B$fl %in% otherSubjects]='other'

# Add label for new Experiment (Exp) variable in the dataframes for Ambiguous/critical and Control trials
resAll1B$Exp = "1B" #Experiment 1B: folder orientation varies = always aligned with other 
resAllError1B$Exp = "1B" #Experiment 1B: folder orientation varies = always aligned with other 

```


## Preliminaries for both experiments 

We combine the dataframes for the two experiments and recode some of the variables.

Specifically, we create an "axis" variable, for which we combine "left-right" instructions to refer to the "lateral" axis, and "front-back" instructions to refer to the "sagittal" axis. This decision is motivated in more detail in the manuscript.

We create a new variable for offset, for which we assign "90"" degree offset to speaker positions 90 and 270, as we don't expect a difference between the two. For ambiguous trials this contrasts with the "180" offset; for control trials, with "0" offset.

```{r}

# Combine the two dataframes for ambiguous/critical trials
resAll = rbind(resAll1A, resAll1B)


# Combine the two dataframes for control trials
resAllError = rbind(resAllError1A, resAllError1B)

# Let's create axis variable to compress front-back and left-right instuctions into a sagittal and lateral axis
resAll$axis = 'sagittal'
resAll$axis[resAll$instruction %in% c('righ','left')]='lateral'

# Let's compress 90 and 270 speaker positions into a 90 offset
resAll$offset = '180'
resAll$offset[resAll$ppos %in% c('init_90','init_270')]='90'

# Create egocentric choice variable
resAll$egoChoice = 1*(resAll$chosen!=resAll$other)

# Let's create the axis variable for control trials
resAllError$axis = 'sagittal'
resAllError$axis[resAllError$instruction %in% c('righ','left')]='lateral'

# Let's compress 90 and 270 speaker positions into a 90 offset
resAllError$offset = '0'
resAllError$offset[resAllError$ppos %in% c('init_90','init_270')]='90'

```

## Descriptives

Let's get some descriptives for ambiguous and control trials 

```{r}

# Ambiguous/critical trials (excluding offset, to simplify)

#reconvert egoChoice to numeric if it was a factor for lmers
#resAll$egoChoice = as.numeric(as.matrix(resAll$egoChoice))
pander(aggregate(egoChoice~Exp,data=resAll,FUN=mean))
#pander(aggregate(RTDV~perspectivePreference+Exp+axis,data=resAll,FUN=mean))
#pander(aggregate(totalDistanceDV~perspectivePreference+Exp+axis,data=resAll,FUN=mean))
#pander(aggregate(xFlipDV~perspectivePreference+Exp+axis,data=resAll,FUN=mean))

#This is to investigate what mixed responders are doing across trials in the two exps.
#resAllmixed = resAll[resAll$perspectivePreference == 'mixed',]
#options(max.print=999999)
#pander(aggregate(egoChoice~Exp+trial+fl+perspectivePreference,data=resAllmixed,FUN=mean))


# Control trials (excluding offset, to simplify)
#reconvert egoChoice to numeric if it was a factor for lmers
#resAllError$err = as.numeric(as.matrix(resAllError$err))

#pander(aggregate(err~perspectivePreference+Exp,data=resAllError,FUN=mean)) #mixed responders have high errors .25 (this is due to front-back trials, see below)
#pander(aggregate(RTDV~perspectivePreference+offset+axis+Exp,data=resAllError,FUN=mean))
#pander(aggregate(totalDistanceDV~perspectivePreference+axis+Exp,data=resAllError,FUN=mean))
#pander(aggregate(xFlipDV~perspectivePreference+axis+Exp,data=resAllError,FUN=mean))

```

## Exploratory plotting of DVs across trials to explore stabilization

We are interested in how egocentric perspective selection might differ over time in the two experiments. 
Here, we plot the proportion of egocentric choices on ambigous trials over time (i.e. across trial order).

```{r}

### Perspective choice by trial, in the two Exps ###

perspectiveByTrial1A = aggregate((1*(resAll1A$chosen!=resAll1A$other))~resAll1A$trial,FUN=mean)
perspectiveByTrial1B = aggregate(( 1*(resAll1B$chosen!=resAll1B$other))~resAll1B$trial,FUN=mean)

plot(perspectiveByTrial1A, main="Egocentric choice selection across trials in Exp 1A",
     xlab = "Trial number", ylab = "Mean proportion of egocentric choice", ylim = c(0, .90))

plot(perspectiveByTrial1B, main="Egocentric choice selection across trials in Exp 1B",
     xlab = "Trial number", ylab = "Mean proportion of egocentric choice", ylim = c(0, .90))
```

Let's look at other-centric responders only, in the two experiments. 

```{r}

perspectiveByTrial1A_Othercentric = aggregate((1*(resAll1A$chosen[resAll1A$perspectivePreference %in% c('other')]!=resAll1A$other[resAll1A$perspectivePreference %in% c('other')]))~resAll1A$trial[resAll1A$perspectivePreference %in% c('other')],FUN=mean)
perspectiveByTrial1B_Othercentric = aggregate((1*(resAll1B$chosen[resAll1B$perspectivePreference %in% c('other')]!=resAll1B$other[resAll1B$perspectivePreference %in% c('other')]))~resAll1B$trial[resAll1B$perspectivePreference %in% c('other')],FUN=mean)

plot(perspectiveByTrial1A_Othercentric, # main="Egocentric choice selection of Other-centric responders across trials in Exp 1A",
     xlab = "Trial number", ylab = "Mean proportion of egocentric choice", ylim = c(0,.90))

plot(perspectiveByTrial1B_Othercentric, #main="Egocentric choice selection of Other-centric responders across trials in Exp 1B",
     xlab = "Trial number", ylab = "Mean proportion of egocentric choice", ylim = c(0, .90))

```

Let's look at other DVs, specifically Response Time 

```{r}

RTByTrial1A = aggregate((1*(resAll1A$RTDV))~resAll1A$trial,FUN=mean)
RTByTrial1B = aggregate(( 1*(resAll1B$RTDV))~resAll1B$trial,FUN=mean)

plot(RTByTrial1A, main="Mean RT across trials in Exp 1A",
     xlab = "Trial number", ylab = "Response Time")

plot(RTByTrial1B, main="Mean RT across trials in Exp 1B",
     xlab = "Trial number", ylab = "Response Time")

```

## Experiment comparisons

Before getting to the LMERs, let's compare the distribution of other, ego, mixed responders across experiments.

Let's first compare the distribution of other, ego, mixed responders in Exp 1A vs. Exp 1B.

```{r}

preferenceCounts <- matrix(c(59, 18, 18, 43, 33, 17), ncol=3, byrow=TRUE)
colnames(preferenceCounts) <- c("other", "ego", "mixed")
rownames(preferenceCounts) <- c("GDD1B", "GDD1A")
preferenceCounts <- as.table(preferenceCounts)
summary(preferenceCounts)
#chisq.test(preferenceCounts)

```

Let's also compare the distributions when the classification in ego, other, mixed is based on lateral instructions only (left-right only).

This is because mixed responders (based on the previous classification, on all instruction types), made high errors on control front-back trials (esp in Exp 1B), possibly due to using a different mapping to interpret front-back. This may suggest that their responses on ambiguous trials may have not been "mixed" or random but may have simply reflected this different mapping on front-back trials. We make this point in the paper.


```{r}

preferenceCounts <- matrix(c(61, 25, 9, 29, 42, 22), ncol=3, byrow=TRUE)
colnames(preferenceCounts) <- c("other", "ego", "mixed")
rownames(preferenceCounts) <- c("GDD1B", "GDD1A")
preferenceCounts <- as.table(preferenceCounts)
summary(preferenceCounts)
#chisq.test(preferenceCounts)

```

Let's finally compare the distribution of other, ego, mixed responders in GDD1A vs. DDK study 1 
In DDK1 there were 43 other, 31 ego, and 8 mixed. 


```{r}

preferenceCounts <- matrix(c(43, 33, 17, 43, 31, 8), ncol=3, byrow=TRUE)
colnames(preferenceCounts) <- c("other", "ego", "mixed")
rownames(preferenceCounts) <- c("GDD1A", "DDKstudy1")
preferenceCounts <- as.table(preferenceCounts)
summary(preferenceCounts)
#chisq.test(preferenceCounts) 

#The two distributions don't differ significantly. Good news for replication.

```

## Linear mixed effects models for ambiguous (critical) trials

We create separate linear mixed effects models for each of the dependent variables (proportion of egocentric choices, RT, total Distance, x-flips) on ambiguous/critical trials, combining the data from Experiment 1a and 1b. 

We start with some pre-processing of the variables, setting the reference categories where relevant, and inspecting the data structure.

```{r}

resAll = as.data.frame(as.matrix(resAll))
#Defining as factors in order to set reference categories next


resAll$perspectivePreference = factor(resAll$perspectivePreference)
resAll$axis = factor(resAll$axis)
resAll$offset = factor(resAll$offset)
resAll$egoChoice = factor(resAll$egoChoice)
resAll$trial = as.integer(as.matrix(resAll$trial))
resAll$fl = as.factor(as.matrix(resAll$fl))
str(resAll)

contrasts(resAll$Exp)
contrasts(resAll$perspectivePreference)
contrasts(resAll$axis)
contrasts(resAll$offset)


#make sure DVs are of the right type
resAll$RTDV = as.numeric(as.matrix(resAll$RTDV))
resAll$totalDistanceDV = as.numeric(as.matrix(resAll$totalDistanceDV))
resAll$xFlipDV = as.integer(as.matrix(resAll$xFlipDV))
resAll$egoChoice = as.factor(as.matrix(resAll$egoChoice))

##Check for any "holes" in the design
#with(resAll, table(Exp, offset, axis, perspectivePreference))
#str(resAll)

#Center time/trial
resAll$centered_trial =scale(resAll$trial)

```

Step 1: Let's set up the contrast structure for each factor of interest (axis, preference, offset)

```{r}

resAll.cont <- within(resAll, {
  
  # Factor 1: instruction type 
  axis.latVsag <- ifelse( axis=="lateral", 1/2, 
                          ifelse( axis=="sagittal", -1/2, NA ) ) 
  
  # Factor 2: Perspective preference
  PP.othVego <- ifelse( perspectivePreference=="other", 1/2,
                        ifelse( perspectivePreference=="mixed", 0,
                                ifelse( perspectivePreference=="ego", -1/2, NA )))
  
  PP.mixVego <- ifelse( perspectivePreference=="other", 0,
                        ifelse( perspectivePreference=="mixed", 1/2,
                                ifelse( perspectivePreference=="ego", -1/2, NA )))    
  
  # Factor 3: Orientation of folders
  orient.otherVego <- ifelse( Exp=="2B", 1/2, 
                               ifelse( Exp=="2A", -1/2, NA ) ) 
  
  # Factor 4: Speaker position (offset)
  
  offset.180v90 <- ifelse( offset=="180", 1/2, 
                              ifelse( offset=="90", -1/2, NA ) )  
  
  })
  

```

Step 2: let's build the omnibus model for each DV with all effects of interest for research questions

```{r}

## Response time ##

RTModel.omni <- lmer( log(RTDV) ~ (1 | fl) 
                      + (0 + offset.180v90 | fl) 
                      + (0 + axis.latVsag | fl) 
                      + (0 + (axis.latVsag:offset.180v90) | fl) 
                      + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                      data=resAll.cont, REML=FALSE )
summary(RTModel.omni)
#print('RT:'); pander(print_stats(RTModel.omni))

## Distance ##

DistanceModel.omni <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                      + (0 + offset.180v90 | fl) 
                      + (0 + axis.latVsag | fl) 
                      + (0 + (axis.latVsag:offset.180v90) | fl)
                      + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                      data=resAll.cont, REML=FALSE )
summary(DistanceModel.omni)
#print('Distance:'); pander(print_stats(DistanceModel.omni))


## Directional Shifts ##

xFlipModel.omni <- lmer( xFlipDV ~ (1 | fl) 
                            + (0 + offset.180v90 | fl) 
                            + (0 + axis.latVsag | fl) 
                            + (0 + (axis.latVsag:offset.180v90) | fl)
                            + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),  
                            #family = "poisson",
                            data=resAll.cont, REML=FALSE )
summary(xFlipModel.omni) 
#print('Directional Shifts:'); pander(print_stats(xFlipModel.omni))


# Egocentric Choice models

ChoiceModel.omni <- glmer(egoChoice ~ (1 | fl)
                          #+ (0 + offset.180v90 | fl) 
                          #+ (0 + axis.latVsag | fl) 
                          #+ (0 + (axis.latVsag:offset.180v90) | fl)
                          + orient.otherVego * offset.180v90 * axis.latVsag, 
                          data=resAll.cont,
                          family = "binomial",
                          # method = "Laplace",
                          nAGQ = 1, #due to warning message, model converges with this
                          REML = FALSE)
summary(ChoiceModel.omni)

```

Step 3: Get the effect sizes of omnibus based on the MuMIn package - designed for mixed effects models

```{r}
#changing the format of the random effect structure to overcome issues with the MuMIn package
RTModel.omni <- lmer( log(RTDV) ~ (1 + offset.180v90 + axis.latVsag + (axis.latVsag:offset.180v90) | fl) 
                      + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                      data=resAll.cont, REML=FALSE )
r.squaredGLMM(RTModel.omni)[1]
r.squaredGLMM(RTModel.omni)[2]

#alternative computation of R-squared from Xu (2003)
r.sqrt=1-var(residuals(RTModel.omni))/(var(model.response(model.frame(RTModel.omni))))

#changing the format of the random effect structure to overcome issues with the MuMIn package
DistanceModel.omni <- lmer( log(totalDistanceDV) ~ (1 + offset.180v90 + axis.latVsag + (axis.latVsag:offset.180v90) | fl) 
                            + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                            data=resAll.cont, REML=FALSE )
r.squaredGLMM(DistanceModel.omni)[1]
r.squaredGLMM(DistanceModel.omni)[2]

#changing the format of the random effect structure to overcome issues with the MuMIn package
xFlipModel.omni <- lmer( xFlipDV ~ (1 + offset.180v90 +axis.latVsag + (axis.latVsag:offset.180v90) | fl) 
                         + orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),  
                         #family = "poisson",
                         data=resAll.cont, REML=FALSE )

r.squaredGLMM(xFlipModel.omni)[1]
r.squaredGLMM(xFlipModel.omni)[2]

#Choice model only has random intercept in random effect structure; no changes needed
r.squaredGLMM(ChoiceModel.omni)[1]
r.squaredGLMM(ChoiceModel.omni)[2] #even though the model converges when ran, I'm getting warnings here

```

STEP 4a: In order to interpret the individual coefficients of the 2-way and 3-way interactions, we need to first establish that the overall interactions are statisticall significant
## Note: Testing the 2-way interaction between perspectivePreference and config

```{r}

#This function cleans up the output of the likelihood-ratio tests
modComp = function(model1,model2,modname){
  
  llcomp = anova(model1,model2)
  df1 = llcomp$"Chi Df"[2]
  chi1 = llcomp$"Chisq"[2]
  pr1 = llcomp$"Pr(>Chisq)"[2]
  
  test1 = data.frame(c(df1,chi1,pr1))
  colnames(test1) = modname
  rownames(test1) = c("df","chi","p")
  return(test1)
}

## Note: what this does below is remove the critical 2-way interaction coefficients from the omnibus and then compares to the omni with likelihood ratio test

#1 Orientation x Perspective Preference 
twoway.RTModel.OrientvsPP = update(RTModel.omni,.~.-PP.othVego:orient.otherVego
                                   -PP.mixVego:orient.otherVego)
modComp(RTModel.omni,twoway.RTModel.OrientvsPP,"twoway.RTModel.OrientvsPP")

twoway.DistanceModel.OrientvsPP = update(DistanceModel.omni,.~.-PP.othVego:orient.otherVego
                                   -PP.mixVego:orient.otherVego)
modComp(DistanceModel.omni,twoway.DistanceModel.OrientvsPP,"twoway.DistanceModel.OrientvsPP")

twoway.xFlipModel.OrientvsPP = update(xFlipModel.omni,.~.-PP.othVego:orient.otherVego
                                         -PP.mixVego:orient.otherVego)
modComp(xFlipModel.omni,twoway.xFlipModel.OrientvsPP,"twoway.xFlipModel.OrientvsPP")

#2 Orientation x Offset
twoway.RTModel.OrientvsOffset = update(RTModel.omni,.~.-orient.otherVego:offset.180v90)
modComp(RTModel.omni,twoway.RTModel.OrientvsOffset,"twoway.RTModel.OrientvsOffset")

twoway.DistanceModel.OrientvsOffset = update(DistanceModel.omni,.~.-orient.otherVego:offset.180v90)
modComp(DistanceModel.omni,twoway.DistanceModel.OrientvsOffset,"twoway.DistanceModel.OrientvsOffset")

twoway.xFlipModel.OrientvsOffset = update(xFlipModel.omni,.~.-orient.otherVego:offset.180v90)
modComp(xFlipModel.omni,twoway.xFlipModel.OrientvsOffset,"twoway.xFlipModel.OrientvsOffset")

twoway.ChoiceModel.OrientvsOffset = update(ChoiceModel.omni,.~.-orient.otherVego:offset.180v90)
modComp(ChoiceModel.omni,twoway.ChoiceModel.OrientvsOffset,"twoway.ChoiceModel.OrientvsOffset")

#3 Orientation x Axis (instruction type)
twoway.RTModel.OrientvsAxis = update(RTModel.omni,.~.-orient.otherVego:axis.latVsag)
modComp(RTModel.omni,twoway.RTModel.OrientvsAxis,"twoway.RTModel.OrientvsAxis")

twoway.DistanceModel.OrientvsAxis = update(DistanceModel.omni,.~.-orient.otherVego:axis.latVsag)
modComp(DistanceModel.omni,twoway.DistanceModel.OrientvsAxis,"twoway.DistanceModel.OrientvsAxis")

twoway.xFlipModel.OrientvsAxis = update(xFlipModel.omni,.~.-orient.otherVego:axis.latVsag)
modComp(xFlipModel.omni,twoway.xFlipModel.OrientvsAxis,"twoway.xFlipModel.OrientvsAxis")

twoway.ChoiceModel.OrientvsAxis = update(ChoiceModel.omni,.~.-orient.otherVego:axis.latVsag)
modComp(ChoiceModel.omni,twoway.ChoiceModel.OrientvsAxis,"twoway.ChoiceModel.OrientvsAxis")

#4 Preference x Axis (instruction type)
twoway.RTModel.PPvsAxis = update(RTModel.omni,.~.-PP.othVego:axis.latVsag
                                   -PP.mixVego:axis.latVsag)
modComp(RTModel.omni,twoway.RTModel.PPvsAxis,"twoway.RTModel.PPvsAxis")

twoway.DistanceModel.PPvsAxis = update(DistanceModel.omni,.~.-PP.othVego:axis.latVsag
                                 -PP.mixVego:axis.latVsag)
modComp(DistanceModel.omni,twoway.DistanceModel.PPvsAxis,"twoway.DistanceModel.PPvsAxis")

twoway.xFlipModel.PPvsAxis = update(xFlipModel.omni,.~.-PP.othVego:axis.latVsag
                                       -PP.mixVego:axis.latVsag)
modComp(xFlipModel.omni,twoway.xFlipModel.PPvsAxis,"twoway.xFlipModel.PPvsAxis")

#5 Preference x Offset
twoway.RTModel.PPvsOffset = update(RTModel.omni,.~.-PP.othVego:offset.180v90
                                 -PP.mixVego:offset.180v90)
modComp(RTModel.omni,twoway.RTModel.PPvsOffset,"twoway.RTModel.PPvsOffset")

twoway.DistanceModel.PPvsOffset = update(DistanceModel.omni,.~.-PP.othVego:offset.180v90
                                   -PP.mixVego:offset.180v90)
modComp(DistanceModel.omni,twoway.DistanceModel.PPvsOffset,"twoway.DistanceModel.PPvsOffset")

twoway.xFlipModel.PPvsOffset = update(xFlipModel.omni,.~.-PP.othVego:offset.180v90
                                         -PP.mixVego:offset.180v90)
modComp(xFlipModel.omni,twoway.xFlipModel.PPvsOffset,"twoway.xFlipModel.PPvsOffset")

#6 Axis x Offset
twoway.RTModel.AxisvsOffset = update(RTModel.omni,.~.-axis.latVsag:offset.180v90)
modComp(RTModel.omni,twoway.RTModel.AxisvsOffset,"twoway.RTModel.AxisvsOffset")

twoway.DistanceModel.AxisvsOffset = update(DistanceModel.omni,.~.-axis.latVsag:offset.180v90)
modComp(DistanceModel.omni,twoway.DistanceModel.AxisvsOffset,"twoway.DistanceModel.AxisvsOffset")

twoway.xFlipModel.AxisvsOffset = update(xFlipModel.omni,.~.-axis.latVsag:offset.180v90)
modComp(xFlipModel.omni,twoway.xFlipModel.AxisvsOffset,"twoway.xFlipModel.AxisvsOffset")

twoway.ChoiceModel.AxisvsOffset = update(ChoiceModel.omni,.~.-axis.latVsag:offset.180v90)
modComp(ChoiceModel.omni,twoway.ChoiceModel.AxisvsOffset,"twoway.ChoiceModel.AxisvsOffset")

```

STEP 4b: In order to interpret the individual coefficients of the 2-way interactions, we need to first establish that the overall 3-way interactions are statisticall significant
## Testing the 3-way interaction between perspectivePreference, folder orientation, speaker position, and axis

```{r}
#1
threeway.RTModel.OrientvsAxisvsOffset = update(RTModel.omni,.~.-axis.latVsag:orient.otherVego:offset.180v90)
modComp(RTModel.omni,threeway.RTModel.OrientvsAxisvsOffset,"threeway.RTModel_1")

threeway.DistanceModel.OrientvsAxisvsOffset = update(DistanceModel.omni,.~.-axis.latVsag:orient.otherVego:offset.180v90)
modComp(DistanceModel.omni,threeway.DistanceModel.OrientvsAxisvsOffset,"threeway.DistanceModel_1")

threeway.xFlipModel.OrientvsAxisvsOffset = update(xFlipModel.omni,.~.-axis.latVsag:orient.otherVego:offset.180v90)
modComp(xFlipModel.omni,threeway.xFlipModel.OrientvsAxisvsOffset,"threeway.xFlipModel_1")

threeway.ChoiceModel.OrientvsAxisvsOffset = update(ChoiceModel.omni,.~.-axis.latVsag:orient.otherVego:offset.180v90)
modComp(ChoiceModel.omni,threeway.ChoiceModel.OrientvsAxisvsOffset,"threeway.ChoiceModel_1")

#2
threeway.RTModel.OrientvsAxisvsPP = update(RTModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego
                                           -axis.latVsag:PP.mixVego:orient.otherVego)
modComp(RTModel.omni,threeway.RTModel.OrientvsAxisvsPP,"threeway.RTModel_2")

threeway.DistanceModel.OrientvsAxisvsPP = update(DistanceModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego
                                           -axis.latVsag:PP.mixVego:orient.otherVego)
modComp(DistanceModel.omni,threeway.DistanceModel.OrientvsAxisvsPP,"threeway.DistanceModel_2")

threeway.xFlipModel.OrientvsAxisvsPP = update(xFlipModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego
                                                 -axis.latVsag:PP.mixVego:orient.otherVego)
modComp(xFlipModel.omni,threeway.xFlipModel.OrientvsAxisvsPP,"threeway.xFlipModel_2")

#3
threeway.RTModel.AxisvsPPvsOffset = update(RTModel.omni,.~.-axis.latVsag:PP.othVego:offset.180v90
                         -axis.latVsag:PP.mixVego:offset.180v90)
modComp(RTModel.omni,threeway.RTModel.AxisvsPPvsOffset,"threeway.RTModel_3")

threeway.DistanceModel.AxisvsPPvsOffset = update(DistanceModel.omni,.~.-axis.latVsag:PP.othVego:offset.180v90
                                                 -axis.latVsag:PP.mixVego:offset.180v90)
modComp(DistanceModel.omni,threeway.DistanceModel.AxisvsPPvsOffset,"threeway.DistanceModel_3")

threeway.xFlipModel.AxisvsPPvsOffset = update(xFlipModel.omni,.~.-axis.latVsag:PP.othVego:offset.180v90
                                                 -axis.latVsag:PP.mixVego:offset.180v90)
modComp(xFlipModel.omni,threeway.xFlipModel.AxisvsPPvsOffset,"threeway.xFlipModel_3")

#4
threeway.RTModel.PPvsOrientvsOffset = update(RTModel.omni,.~.-PP.othVego:orient.otherVego:offset.180v90
                                             -PP.mixVego:orient.otherVego:offset.180v90)
modComp(RTModel.omni,threeway.RTModel.PPvsOrientvsOffset,"threeway.RTModel_4")

threeway.DistanceModel.PPvsOrientvsOffset = update(DistanceModel.omni,.~.-PP.othVego:orient.otherVego:offset.180v90
                                             -PP.mixVego:orient.otherVego:offset.180v90)
modComp(DistanceModel.omni,threeway.DistanceModel.PPvsOrientvsOffset,"threeway.DistanceModel_4")

threeway.xFlipModel.PPvsOrientvsOffset = update(xFlipModel.omni,.~.-PP.othVego:orient.otherVego:offset.180v90
                                                   -PP.mixVego:orient.otherVego:offset.180v90)
modComp(xFlipModel.omni,threeway.xFlipModel.PPvsOrientvsOffset,"threeway.xFlipModel_4")

```

STEP 4c: In order to interpret the individual coefficients of the 2-way and 3-way interactions, we need to first establish that the overall interactions are statisticall significant
## Testing the 4-way interaction between perspectivePreference, folder orientation, speaker position, and axis

```{r}


fourway.RTModel = update(RTModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90)
modComp(RTModel.omni,fourway.RTModel,"fourway.RTModel")


fourway.DistanceModel = update(DistanceModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90
                         -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90)
modComp(DistanceModel.omni,fourway.DistanceModel,"fourway.DistanceModel")

fourway.xFlipModel = update(xFlipModel.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                               -axis.latVsag:PP.othVego:orient.otherVego:offset.180v90
                               -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90
                               -axis.latVsag:PP.mixVego:orient.otherVego:offset.180v90)
modComp(xFlipModel.omni,fourway.xFlipModel,"fourway.xFlipModel")

```

STEP 5: We have an overall significant 3-way interaction, between perspective preference, folder orientation, and axis, so we need to decompose holding each level of axis constant and rerun. This is a simple effects follow-up of the 3-way interaction.

# Important note: We need to pay attention to effects in the following models that do NOT interact with the dummy codes (axis.lat and axis.sag) (i.e., ignore any fixed effect that includes "axis.lat" or "axis.sag," whether it is an interaction or main effect)"

```{r}


resAll.cont <- within(resAll.cont, {
  
  axis.lat <- ifelse( axis=="lateral", 0, 
                      ifelse( axis=="sagittal", 1, NA ) ) 
  
  axis.sag <- ifelse( axis=="lateral", 1, 
                      ifelse( axis=="sagittal", 0, NA ) ) 
} )

#######
##// Axis: Lateral
#######

lat.omni.RT <- lmer( log(RTDV) ~ (1 | fl) 
                      + (0 + axis.lat | fl) 
                      + (0 + offset.180v90 | fl)
                      + (0 + axis.lat:offset.180v90 | fl)
                      + orient.otherVego * axis.lat * offset.180v90 * (PP.othVego + PP.mixVego),        
                      data=resAll.cont, REML=FALSE )
summary(lat.omni.RT) 

lat.omni.Distance <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                     + (0 + axis.lat | fl) 
                     + (0 + offset.180v90 | fl)
                     + (0 + axis.lat:offset.180v90 | fl)
                     + orient.otherVego * axis.lat * offset.180v90 * (PP.othVego + PP.mixVego),        
                     data=resAll.cont, REML=FALSE )
summary(lat.omni.Distance) 

lat.omni.xFlip <- lmer( xFlipDV ~ (1 | fl) 
                           + (0 + axis.lat | fl) 
                           + (0 + offset.180v90 | fl)
                           + (0 + axis.lat:offset.180v90 | fl)
                           + orient.otherVego * axis.lat * offset.180v90 * (PP.othVego + PP.mixVego),        
                           data=resAll.cont, REML=FALSE )
summary(lat.omni.xFlip) 


##// test for two-way interaction of perspectivePreference and orientation in order to follow-up
lat.RT = update( lat.omni.RT, .~.-PP.othVego:orient.otherVego
                 -PP.mixVego:orient.otherVego)
modComp(lat.omni.RT,lat.RT,"lat.omnibus.RT")

lat.Distance = update( lat.omni.Distance, .~.-PP.othVego:orient.otherVego
                 -PP.mixVego:orient.otherVego)
modComp(lat.omni.Distance,lat.Distance,"lat.omnibus.Distance")

lat.xFlip = update( lat.omni.xFlip, .~.-PP.othVego:orient.otherVego
                       -PP.mixVego:orient.otherVego)
modComp(lat.omni.xFlip,lat.xFlip,"lat.omnibus.xFlip")
# p = .08

#######
##// Axis: Sagittal
#######

sag.omni.RT <- lmer( log(RTDV) ~ (1 | fl) 
                     + (0 + axis.sag | fl) 
                     + (0 + offset.180v90 | fl)
                     + (0 + axis.sag:offset.180v90 | fl)
                     + orient.otherVego * axis.sag * offset.180v90 * (PP.othVego + PP.mixVego),        
                     data=resAll.cont, REML=FALSE )
summary(sag.omni.RT) 

sag.omni.Distance <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                     + (0 + axis.sag | fl) 
                     + (0 + offset.180v90 | fl)
                     + (0 + axis.sag:offset.180v90 | fl)
                     + orient.otherVego * axis.sag * offset.180v90 * (PP.othVego + PP.mixVego),        
                     data=resAll.cont, REML=FALSE )
summary(sag.omni.Distance) 

sag.omni.xFlip <- lmer( xFlipDV ~ (1 | fl) 
                           + (0 + axis.sag | fl) 
                           + (0 + offset.180v90 | fl)
                           + (0 + axis.sag:offset.180v90 | fl)
                           + orient.otherVego * axis.sag * offset.180v90 * (PP.othVego + PP.mixVego),        
                           data=resAll.cont, REML=FALSE )
summary(sag.omni.xFlip)

##// test for two-way interaction of perspectivePreference and orientation in order to follow-up
sag.RT = update( sag.omni.RT, .~.-PP.othVego:orient.otherVego
                 -PP.mixVego:orient.otherVego)
modComp(sag.omni.RT,sag.RT,"sag.omnibus.RT")

sag.Distance = update( sag.omni.Distance, .~.-PP.othVego:orient.otherVego
                 -PP.mixVego:orient.otherVego)
modComp(sag.omni.Distance,sag.Distance,"sag.omnibus.Distance")

sag.xFlip = update( sag.omni.xFlip, .~.-PP.othVego:orient.otherVego
                       -PP.mixVego:orient.otherVego)
modComp(sag.omni.xFlip,sag.xFlip,"sag.omnibus.xFlip")
# p = .07

```

##### Now let's examine the effect of trial ##### 

```{r}

resAll.cont$centered_trial =scale(resAll.cont$trial)



## Response time ##

RTModel.time <- lmer( log(RTDV) ~ (1 | fl) 
                      + (0 + offset.180v90 | fl) 
                      + (0 + axis.latVsag | fl) 
                      + (0 + centered_trial | fl) 
                      + (0 + (axis.latVsag:offset.180v90) | fl) 
                      + centered_trial * orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                      data=resAll.cont, REML=FALSE )
summary(RTModel.time) 


## Distance ##

DistanceModel.time <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                            + (0 + offset.180v90 | fl) 
                            + (0 + axis.latVsag | fl) 
                            + (0 + centered_trial | fl) 
                            + (0 + (axis.latVsag:offset.180v90) | fl)
                            + centered_trial * orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),        
                            data=resAll.cont, REML=FALSE )
summary(DistanceModel.time) 


## Directional Shifts ##

xFlipModel.time <- lmer( xFlipDV ~ (1 | fl) 
                         + (0 + offset.180v90 | fl) 
                         + (0 + axis.latVsag | fl) 
                         + (0 + centered_trial | fl)
                         + (0 + (axis.latVsag:offset.180v90) | fl)
                         + centered_trial * orient.otherVego * offset.180v90 * axis.latVsag * (PP.othVego + PP.mixVego),  
                         #family = "poisson",
                         data=resAll.cont, REML=FALSE )
summary(xFlipModel.time) 


# Egocentric Choice models

ChoiceModel.time <- glmer(egoChoice ~ (1 | fl)
                          #+ (0 + offset.180v90 | fl) 
                          #+ (0 + axis.latVsag | fl) 
                          #+ (0 + (axis.latVsag:offset.180v90) | fl)
                          #+ (0 + centered_trial | fl)
                          + centered_trial * orient.otherVego * offset.180v90 * axis.latVsag, 
                          data=resAll.cont,
                          family = "binomial",
                          # method = "Laplace",
                          nAGQ = 1, #due to warning message, model converges with this
                          REML = FALSE)
summary(ChoiceModel.time)

```

##### Follow-up analyses excluding mixed responders (reported in Appendix B) ######

```{r}

resAll_NoMixed = subset(resAll, resAll$perspectivePreference %in% c('ego','other'))

resAll_NoMixed <- within(resAll_NoMixed, {
  
  # Factor 1: instruction type 
  axis.latVsag <- ifelse( axis=="lateral", 1/2, 
                          ifelse( axis=="sagittal", -1/2, NA ) ) 
  
  # Factor 2: Perspective preference
  PP.othVego <- ifelse( perspectivePreference=="other", 1/2,
                        ifelse( perspectivePreference=="ego", -1/2, NA ))
  
  # Factor 3: Orientation of folders
  orient.otherVego <- ifelse( Exp=="2B", 1/2, 
                              ifelse( Exp=="2A", -1/2, NA ) ) 
  
  # Factor 4: Speaker position (offset)
  
  offset.180v90 <- ifelse( offset=="180", 1/2, 
                           ifelse( offset=="90", -1/2, NA ) )  
  
})


RTModel_NoMixed.omni <- lmer( log(RTDV) ~ (1 | fl) 
                      + (0 + offset.180v90 | fl) 
                      + (0 + axis.latVsag | fl) 
                      + (0 + (axis.latVsag:offset.180v90) | fl) 
                      + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,        
                      data=resAll_NoMixed, REML=FALSE )
summary(RTModel_NoMixed.omni) 


#checking if this overall 3-way interaction is significant, as it is as a predictor in the omnbibus
threeway.RTModel_NoMixed.OrientvsAxisvsPP = update(RTModel_NoMixed.omni,.~.-axis.latVsag:PP.othVego:orient.otherVego)
modComp(RTModel_NoMixed.omni,threeway.RTModel_NoMixed.OrientvsAxisvsPP,"threeway.RTModel_2")

#Let's do the simple effects follow up for lateral and sagital models
resAll_NoMixed <- within(resAll_NoMixed, {
  
  axis.lat <- ifelse( axis=="lateral", 0, 
                      ifelse( axis=="sagittal", 1, NA ) ) 
  
  axis.sag <- ifelse( axis=="lateral", 1, 
                      ifelse( axis=="sagittal", 0, NA ) ) 
} )


lat.NoMixed.omni.RT <- lmer( log(RTDV) ~ (1 | fl) 
                             + (0 + axis.lat | fl) 
                             + (0 + offset.180v90 | fl)
                             + (0 + axis.lat:offset.180v90 | fl)
                             + orient.otherVego * axis.lat * offset.180v90 * PP.othVego,        
                             data=resAll_NoMixed, REML=FALSE )
summary(lat.NoMixed.omni.RT) 


sag.NoMixed.omni.RT <- lmer( log(RTDV) ~ (1 | fl) 
                     + (0 + axis.sag | fl) 
                     + (0 + offset.180v90 | fl)
                     + (0 + axis.sag:offset.180v90 | fl)
                     + orient.otherVego * axis.sag * offset.180v90 * PP.othVego,        
                     data=resAll_NoMixed, REML=FALSE )
summary(sag.NoMixed.omni.RT) 

##// test for two-way interaction of perspectivePreference and orientation in order to follow-up
lat.NoMixed.RT = update( lat.NoMixed.omni.RT, .~.-PP.othVego:orient.otherVego)
modComp(lat.NoMixed.omni.RT,lat.NoMixed.RT,"sag.omnibus.RT")
# p = .17

sag.NoMixed.RT = update( sag.NoMixed.omni.RT, .~.-PP.othVego:orient.otherVego)
modComp(sag.NoMixed.omni.RT,sag.NoMixed.RT,"sag.omnibus.RT")
# p = .93

# Distance model 

DistanceModel_NoMixed.omni <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                              + (0 + offset.180v90 | fl) 
                              + (0 + axis.latVsag | fl) 
                              + (0 + (axis.latVsag:offset.180v90) | fl) 
                              + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,        
                              data=resAll_NoMixed, REML=FALSE )
summary(DistanceModel_NoMixed.omni) 

# Directional shifts

xFlipModel_NoMixed.omni <- lmer( xFlipDV ~ (1 | fl) 
                                    + (0 + offset.180v90 | fl) 
                                    + (0 + axis.latVsag | fl) 
                                    + (0 + (axis.latVsag:offset.180v90) | fl) 
                                    + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,  
                                    #family = "poisson",
                                    data=resAll_NoMixed, REML=FALSE )
summary(xFlipModel_NoMixed.omni) 

# Egocentric choice models

ChoiceModel_NoMixed.omni <- glmer(egoChoice ~ (1 | fl)
                          #+ (0 + offset.180v90 | fl) 
                          #+ (0 + axis.latVsag | fl) 
                          #+ (0 + (axis.latVsag:offset.180v90) | fl)
                          +  orient.otherVego * offset.180v90 * axis.latVsag, 
                          data=resAll_NoMixed,
                          family = "binomial",
                          # method = "Laplace",
                          nAGQ = 1, #due to warning message, model converges with this
                          REML = FALSE)
summary(ChoiceModel_NoMixed.omni)


##Effect sizes
RTModel_NoMixed.omni <- lmer( log(RTDV) ~ (1 + offset.180v90 + axis.latVsag + (axis.latVsag:offset.180v90)| fl) 
                              + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,        
                              data=resAll_NoMixed, REML=FALSE )

r.squaredGLMM(RTModel_NoMixed.omni)[2]


DistanceModel_NoMixed.omni <- lmer( log(totalDistanceDV) ~ (1 + offset.180v90 + axis.latVsag + (axis.latVsag:offset.180v90) | fl) 
                                    + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,        
                                    data=resAll_NoMixed, REML=FALSE )
r.squaredGLMM(DistanceModel_NoMixed.omni)[2]


xFlipModel_NoMixed.omni <- lmer( xFlipDV ~ (1 + offset.180v90 + axis.latVsag + (axis.latVsag:offset.180v90) | fl) 
                                 + orient.otherVego * offset.180v90 * axis.latVsag * PP.othVego,  
                                 #family = "poisson",
                                 data=resAll_NoMixed, REML=FALSE )
r.squaredGLMM(xFlipModel_NoMixed.omni)[2]

r.squaredGLMM(ChoiceModel_NoMixed.omni)[2] 

```

##### LMERS FOR CONTROL TRIALS (reported in Appendix A) #####

Preliminaries

```{r}

resAllError = as.data.frame(as.matrix(resAllError))
#Defining as factors in order to set reference categories next
resAllError$Exp = as.factor(as.matrix(resAllError$Exp))
resAllError$offset = as.factor(as.matrix(resAllError$offset))
resAllError$axis = as.factor(as.matrix(resAllError$axis))
resAllError$perspectivePreference = as.factor(as.matrix(resAllError$perspectivePreference))

##Check for any "holes" in the design
with(resAllError, table(Exp, offset, axis, perspectivePreference))
str(resAllError)

#To remove mixed responders who have high errors
#resAllError = subset(resAllError, resAllError$perspectivePreference != "mixed")

#make sure the DVs are of the appropriate type
resAllError$err = as.factor(as.matrix(resAllError$err))
resAllError$RTDV = as.numeric(as.matrix(resAllError$RTDV))
resAllError$totalDistanceDV = as.numeric(as.matrix(resAllError$totalDistanceDV))
resAllError$xFlipDV = as.integer(as.matrix(resAllError$xFlipDV))

```

Step 1: Set up contrast structure

```{r}

resAllError.cont <- within(resAllError, {
  
  # Factor 1: instruction type 
  axis.latVsag <- ifelse( axis=="lateral", 1/2, 
                          ifelse( axis=="sagittal", -1/2, NA ) ) 
  
  # Factor 2: Perspective preference
  PP.othVego <- ifelse( perspectivePreference=="other", 1/2,
                        ifelse( perspectivePreference=="mixed", 0,
                                ifelse( perspectivePreference=="ego", -1/2, NA )))
  
  PP.mixVego <- ifelse( perspectivePreference=="other", 0,
                        ifelse( perspectivePreference=="mixed", 1/2,
                                ifelse( perspectivePreference=="ego", -1/2, NA )))    
  
  # Factor 3: Orientation of folders
  orient.otherVego <- ifelse( Exp=="2B", 1/2, 
                              ifelse( Exp=="2A", -1/2, NA ) ) 
  
  # Factor 4: Speaker position (offset)
  
  offset.90v0 <- ifelse( offset=="90", 1/2, 
                           ifelse( offset=="0", -1/2, NA ) )  
  
})

```

Step 2: Build the omnibus models with all effects of interest for research questions

```{r}

RTModelControl.omni <- lmer( log(RTDV) ~ (1 | fl) 
                      + (0 + offset.90v0 | fl) 
                      + (0 + axis.latVsag | fl) 
                      + (0 + (axis.latVsag:offset.90v0) | fl) 
                      + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),        
                      data=resAllError.cont, REML=FALSE )
summary(RTModelControl.omni) 
print('RT:'); pander(print_stats(RTModelControl.omni))


#changing the format of the random effect structure for MuMIN package
RTModelControl.omni <- lmer( log(RTDV) ~ (1 + offset.90v0 + axis.latVsag + (axis.latVsag:offset.90v0) | fl) 
                             + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),        
                             data=resAllError.cont, REML=FALSE )
r.squaredGLMM(RTModelControl.omni)[2]

## Distance ##

DistanceModelControl.omni <- lmer( log(totalDistanceDV) ~ (1 | fl) 
                            + (0 + offset.90v0 | fl) 
                            + (0 + axis.latVsag | fl) 
                            + (0 + (axis.latVsag:offset.90v0) | fl)
                            + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),        
                            data=resAllError.cont, REML=FALSE )
summary(DistanceModelControl.omni) 
print('Distance:'); pander(print_stats(DistanceModelControl.omni))

DistanceModelControl.omni <- lmer( log(totalDistanceDV) ~ (1 + offset.90v0 + axis.latVsag + (axis.latVsag:offset.90v0) | fl) 
                                   + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),        
                                   data=resAllError.cont, REML=FALSE )
r.squaredGLMM(DistanceModelControl.omni)[2]

## Directional Shifts ##

xFlipModelControl.omni <- lmer( xFlipDV ~ (1 | fl) 
                         + (0 + offset.90v0 | fl) 
                         + (0 + axis.latVsag | fl) 
                         + (0 + (axis.latVsag:offset.90v0) | fl)
                         + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),  
                         #family = "poisson",
                         data=resAllError.cont, REML=FALSE )
summary(xFlipModelControl.omni) 
#print('Directional Shifts:'); pander(print_stats(xFlipModelControl.omni))


xFlipModelControl.omni <- lmer( xFlipDV ~ (1 + offset.90v0 + axis.latVsag + (axis.latVsag:offset.90v0) | fl) 
                                + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego),  
                                #family = "poisson",
                                data=resAllError.cont, REML=FALSE )
r.squaredGLMM(xFlipModelControl.omni)[2]

# Error models

ErrorModel.omni <- glmer(err ~ (1 | fl)
                          #+ (0 + offset.90v0 | fl) 
                          #+ (0 + axis.latVsag | fl) 
                          #+ (0 + (axis.latVsag:offset.90v0) | fl)
                          + orient.otherVego * offset.90v0 * axis.latVsag * (PP.othVego + PP.mixVego), 
                          data=resAllError.cont,
                          family = "binomial",
                          # method = "Laplace",
                          nAGQ = 1,
                          REML = FALSE)
summary(ErrorModel.omni)
r.squaredGLMM(ErrorModel.omni)[2]

```